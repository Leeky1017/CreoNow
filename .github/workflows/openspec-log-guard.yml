name: OpenSpec Log Guard

on:
  pull_request:
    branches: [main]

jobs:
  openspec-log-guard:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Validate completed active changes are archived (tasks.md all checked)
        run: |
          python3 - <<'PY'
          import pathlib
          import re
          import sys

          root = pathlib.Path("openspec/changes")
          active = sorted(
            d for d in root.iterdir()
            if d.is_dir() and not d.name.startswith(".") and d.name not in {"archive", "_template"}
          )

          completed_active = []
          for change_dir in active:
            tasks_path = change_dir / "tasks.md"
            if not tasks_path.is_file():
              continue

            content = tasks_path.read_text(encoding="utf-8")
            marks = re.findall(r"^- \[([ xX])\]", content, flags=re.MULTILINE)
            if marks and all(mark.lower() == "x" for mark in marks):
              completed_active.append(change_dir.name)

          if completed_active:
            print(
              "❌ tasks.md checkboxes are all checked, so completed changes must be archived to "
              "openspec/changes/archive/: "
              + ", ".join(completed_active)
            )
            sys.exit(1)

          print("✅ Completed active change archive guard passed")
          PY

      - name: Validate RUN_LOG or Skip-Reason
        env:
          PR_BODY: ${{ github.event.pull_request.body || '' }}
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          BRANCH="${{ github.head_ref }}"

          if [[ "$BRANCH" =~ ^task/([0-9]+)- ]]; then
            ISSUE_NUM="${BASH_REMATCH[1]}"
            RUN_LOG="openspec/_ops/task_runs/ISSUE-${ISSUE_NUM}.md"

            # Check file exists
            if [ ! -f "$RUN_LOG" ]; then
              echo "❌ RUN_LOG not found: $RUN_LOG"
              exit 1
            fi
            echo "✅ RUN_LOG found: $RUN_LOG"

            # Validate required fields
            MISSING=""
            grep -q "^- Issue:" "$RUN_LOG"   || MISSING="${MISSING} Issue"
            grep -q "^- Branch:" "$RUN_LOG"  || MISSING="${MISSING} Branch"
            grep -q "^- PR:" "$RUN_LOG"      || MISSING="${MISSING} PR"
            grep -q "^## Plan" "$RUN_LOG"    || MISSING="${MISSING} Plan"
            grep -q "^## Runs" "$RUN_LOG"    || MISSING="${MISSING} Runs"

            if [ -n "$MISSING" ]; then
              echo "❌ RUN_LOG missing required fields:${MISSING}"
              exit 1
            fi
            echo "✅ RUN_LOG format validated"

            PR_HEAD_PARENT_SHA="$(git rev-parse "${PR_HEAD_SHA}^" 2>/dev/null || true)"
            if [ -z "$PR_HEAD_PARENT_SHA" ]; then
              git fetch --no-tags --depth=2 origin "$PR_HEAD_SHA" >/dev/null 2>&1 || true
              PR_HEAD_PARENT_SHA="$(git rev-parse "${PR_HEAD_SHA}^" 2>/dev/null || true)"
            fi
            if [ -z "$PR_HEAD_PARENT_SHA" ]; then
              echo "❌ [MAIN_AUDIT] failed to resolve parent SHA for PR head: $PR_HEAD_SHA"
              exit 1
            fi

            python3 - "$RUN_LOG" "$PR_HEAD_SHA" "$PR_HEAD_PARENT_SHA" "$RUN_LOG" <<'PY'
            import pathlib
            import re
            import subprocess
            import sys

            run_log = pathlib.Path(sys.argv[1])
            head_sha = sys.argv[2]
            head_parent_sha = sys.argv[3]
            run_log_rel = sys.argv[4]

            content = run_log.read_text(encoding="utf-8")
            section_match = re.search(
                r"^## Main Session Audit\s*$([\s\S]*?)(?=^##\s|\Z)",
                content,
                re.MULTILINE,
            )
            if not section_match:
                print(f"❌ [MAIN_AUDIT] missing required section '## Main Session Audit' in {run_log}")
                raise SystemExit(1)

            section = section_match.group(1)
            required_fields = (
                "Audit-Owner",
                "Reviewed-HEAD-SHA",
                "Spec-Compliance",
                "Code-Quality",
                "Fresh-Verification",
                "Blocking-Issues",
                "Decision",
            )
            values: dict[str, str] = {}
            for field in required_fields:
                field_match = re.search(rf"^- {re.escape(field)}:\s*(.+)$", section, re.MULTILINE)
                if not field_match:
                    print(f"❌ [MAIN_AUDIT] missing required field '{field}' in {run_log}")
                    raise SystemExit(1)
                value = field_match.group(1).strip()
                if not value:
                    print(f"❌ [MAIN_AUDIT] field '{field}' cannot be empty in {run_log}")
                    raise SystemExit(1)
                values[field] = value

            if values["Audit-Owner"] != "main-session":
                print(f"❌ [MAIN_AUDIT] Audit-Owner must be 'main-session', got '{values['Audit-Owner']}'")
                raise SystemExit(1)

            reviewed_sha = values["Reviewed-HEAD-SHA"]
            if not re.match(r"^[0-9a-fA-F]{40}$", reviewed_sha):
                print(f"❌ [MAIN_AUDIT] Reviewed-HEAD-SHA must be a 40-hex commit sha, got '{reviewed_sha}'")
                raise SystemExit(1)
            if reviewed_sha.lower() != head_parent_sha.lower():
                print(
                    "❌ [MAIN_AUDIT] Reviewed-HEAD-SHA mismatch: "
                    f"audit={reviewed_sha}, expected_head_parent={head_parent_sha}, head={head_sha}"
                )
                raise SystemExit(1)

            for gate_field in ("Spec-Compliance", "Code-Quality", "Fresh-Verification"):
                value = values[gate_field]
                if value not in {"PASS", "FAIL"}:
                    print(f"❌ [MAIN_AUDIT] {gate_field} must be PASS or FAIL, got '{value}'")
                    raise SystemExit(1)
                if value != "PASS":
                    print(f"❌ [MAIN_AUDIT] {gate_field} must be PASS to continue, got '{value}'")
                    raise SystemExit(1)

            blocking_raw = values["Blocking-Issues"]
            if not re.match(r"^\d+$", blocking_raw):
                print(f"❌ [MAIN_AUDIT] Blocking-Issues must be a non-negative integer, got '{blocking_raw}'")
                raise SystemExit(1)
            if int(blocking_raw) != 0:
                print(f"❌ [MAIN_AUDIT] Blocking-Issues must be 0 to continue, got '{blocking_raw}'")
                raise SystemExit(1)

            decision = values["Decision"]
            if decision not in {"ACCEPT", "REJECT"}:
                print(f"❌ [MAIN_AUDIT] Decision must be ACCEPT or REJECT, got '{decision}'")
                raise SystemExit(1)
            if decision != "ACCEPT":
                print(f"❌ [MAIN_AUDIT] Decision must be ACCEPT to continue, got '{decision}'")
                raise SystemExit(1)

            diff_proc = subprocess.run(
                ["git", "diff", "--name-only", "--diff-filter=ACMR", f"{head_parent_sha}..{head_sha}"],
                text=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
            )
            if diff_proc.returncode != 0:
                print("❌ [MAIN_AUDIT] failed to inspect signing commit diff")
                if diff_proc.stdout.strip():
                    print(diff_proc.stdout.rstrip())
                raise SystemExit(1)

            changed_files = [line.strip() for line in diff_proc.stdout.splitlines() if line.strip()]
            if run_log_rel not in changed_files:
                print(f"❌ [MAIN_AUDIT] signing commit must include RUN_LOG update: {run_log_rel}")
                raise SystemExit(1)

            disallowed = sorted(path for path in changed_files if path != run_log_rel)
            if disallowed:
                print(
                    "❌ [MAIN_AUDIT] signing commit must only change RUN_LOG; found additional files: "
                    + ", ".join(disallowed)
                )
                raise SystemExit(1)

            print("✅ Main Session Audit validated")
            PY

          else
            if printf '%s\n' "$PR_BODY" | grep -Eiq '^[[:space:]]*Skip-Reason[[:space:]]*:'; then
              echo "✅ Non-task branch with required Skip-Reason"
            else
              echo "❌ Non-task branch '$BRANCH' must include 'Skip-Reason:' in PR body"
              exit 1
            fi
          fi
