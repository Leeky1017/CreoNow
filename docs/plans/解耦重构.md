# P3 前置"破坏性重构（仅内部破坏）"冻结方案

## Summary

在进入 P3 前，先完成一次**不保留兼容口**的结构重构：删除所有过渡层、旧导出、兼容别名，直接切到新模块边界。  
破坏范围：**仅内部破坏**（不改用户可见行为，不改 IPC channel 对外语义）。  
目标是把高耦合核心链路先"清干净"，避免 P3 功能继续压在巨石上。

---

## 范围决策（已锁定）

- `breaking_scope = 仅内部破坏`
- 含义：
  - 允许破坏内部导入路径、内部函数签名、内部目录结构。
  - 不保留旧 API 兼容层，不做 shim，不做 re-export 过渡文件。
  - **保持** `packages/shared/types/ipc-generated.ts` 对应契约语义稳定（channel 名、错误码、envelope 语义不改）。
  - 保持 UI 交互语义稳定（用户操作路径不变）。

---

## 审计发现（决策依据）

以下问题均通过代码审计确认，是本方案 change 拆分的输入。

### D1 — ServiceResult / ipcError 全局重复

`ServiceResult<T>` 三行定义（`Ok<T>` / `Err` / `ServiceResult<T>`）在 **27 个 service 文件**中各自独立声明。  
`ipcError()` 辅助函数在 **25 个文件**中逐字重复。  
根因：缺少共享基础类型模块。每新增一个 service 文件就复制一次。

涉及文件（部分）：
- `services/ai/aiService.ts`
- `services/ai/aiProxySettingsService.ts`
- `services/ai/judgeQualityService.ts`
- `services/memory/memoryService.ts`
- `services/memory/preferenceLearning.ts`
- `services/memory/episodicMemoryService.ts`
- `services/memory/memoryTraceService.ts`
- `services/memory/userMemoryVec.ts`
- `services/kg/kgService.ts`
- `services/skills/skillService.ts`
- `services/skills/skillExecutor.ts`
- `services/skills/skillScheduler.ts`
- `services/skills/skillLoader.ts`
- `services/skills/skillValidator.ts`
- `services/context/contextFs.ts`
- `services/context/watchService.ts`
- `services/documents/documentService.ts`
- `services/embedding/embeddingService.ts`
- `services/embedding/semanticChunkIndexService.ts`
- `services/search/ftsService.ts`
- `services/search/searchReplaceService.ts`
- `services/search/hybridRankingService.ts`
- `services/projects/projectService.ts`
- `services/stats/statsService.ts`
- `services/export/exportService.ts`
- `services/rag/ragService.ts`
- `services/judge/judgeService.ts`
- `ipc/constraints.ts`
- `ipc/stats.ts`

### D2 — Service create-per-call 反模式（多实例 / 多链路）

无 DI / composition root，核心 service 在每次 IPC 调用时重新 `new`：

| Service Factory | 重复创建位置 | 实例数/调用 |
|---|---|---|
| `createMemoryService` | `ipc/memory.ts`（每 handler 新建 ×8）, `ipc/ai.ts` ×2, `ipc/context.ts` ×1 | **11** |
| `createSkillService` | `ipc/skills.ts`（每 handler 新建 ×9）, `ipc/ai.ts` ×2 | **11** |
| `createKnowledgeGraphService` | `ipc/ai.ts`, `ipc/context.ts`, `ipc/knowledgeGraph.ts`, `kgRecognitionRuntime.ts`, `kgService.ts`（自引用） | **5+** |
| `createContextLayerAssemblyService` | `ipc/ai.ts` ×1, `ipc/context.ts` ×1 | **2**（独立实例，budget 不同步） |

**后果**：
- `contextAssemblyService` 在 `ipc/ai.ts` 和 `ipc/context.ts` 各持有一个实例。`context:budget:update` 只更新 context handler 中的实例；AI skill 运行走的是 ai handler 中的另一个实例 → **budget profile 更新对 AI 调用不生效**。
- 无法在 service 层添加任何有状态缓存（如 KG 查询缓存、skill 解析缓存）。
- 每次 IPC 请求重复执行初始化逻辑。

### D3 — kgService.ts 自引用 Bug

`kgService.ts:2046` — `rulesInjection` 方法内部调用 `createKnowledgeGraphService({ db, logger })` 创建新实例来执行 `queryRelevant()`。应直接调用同一闭包内的 `queryRelevant` 方法。

### D4 — 工具函数重复

| 函数 | 重复位置 |
|---|---|
| `withTimeout` / `runWithTimeout` | `ipc/runtime-validation.ts`, `ipc/version.ts` |
| `sleep` | `ipc/version.ts`, `services/ai/aiService.ts` |
| `normalizeXxx` 系列 | `ipc/version.ts`（3 个）, `ipc/constraints.ts`（多个） |

### D5 — C1-C4 未覆盖的巨石

| 文件 | 大小 | 问题 |
|---|---|---|
| `services/context/layerAssemblyService.ts` | 35KB / 1249 行 | 类型 + 常量 + budget 逻辑 + assembly 管线 + fetcher 编排全在一个文件 |
| `ipc/version.ts` | 24KB / 891 行 | 自带重复的 withTimeout/sleep/retry，handler 巨石 |
| `services/ai/aiProxySettingsService.ts` | 20KB / 699 行 | 独立巨石，与 aiService 同层但未纳入 C2 |
| `ipc/memory.ts` | 16KB | create-per-call 最严重（8 次） |
| `ipc/file.ts` | 16KB | 单文件 handler 模式 |
| `ipc/knowledgeGraph.ts` | 14KB | create-per-call + 单文件 handler |
| `ipc/search.ts` | 12KB | 单文件 handler |
| `services/kg/kgService.ts` | 2162 行 | 包含自引用 bug（D3） |

### D6 — index.ts 半吊子 DI

`index.ts:registerIpcHandlers` 在顶层创建了 `judgeService`, `watchService`, `embeddingService`, `semanticIndex`, `recognitionRuntime` 并注入给 handler。  
但 KG / Memory / Skill / Context / AI 这些核心 service 在各自 `register*` 函数内部独立创建，未经 composition root 管理。  
结果是同一个 `db` 上存在多个互不感知的 service 实例。

---

## Change 拆分（Pre-P3 必做）

### C0 — 共享基础设施提取

#### 目标
消除 27+ 文件的 `ServiceResult<T>` / `ipcError()` 重复；统一工具函数。这是后续所有 change 的前提——不先统一基础类型，后续拆分会继续复制粘贴。

#### 实施
- 新建 `apps/desktop/main/src/lib/service-result.ts`：
  - 导出 `Ok<T>`, `Err`, `ServiceResult<T>`, `ipcError()`
- 新建 `apps/desktop/main/src/lib/async-utils.ts`：
  - 导出 `withTimeout()`, `sleep()`
- 全量替换：27 个 service 文件中的本地 `ServiceResult` 定义 → `import { ServiceResult, ipcError } from '../../lib/service-result'`（路径按实际调整）。
- 删除 `ipc/version.ts` 和 `services/ai/aiService.ts` 中的重复 `sleep` / `withTimeout`，改 import `lib/async-utils`。
- 删除 `ipc/constraints.ts`、`ipc/stats.ts` 中的本地 `ServiceResult` / `ipcError`。

#### 波及
- 所有 `services/**/*.ts`（import 路径变更）
- `ipc/version.ts`, `ipc/constraints.ts`, `ipc/stats.ts`
- 不改任何逻辑，纯 import 替换 + 删除本地定义。

---

### C1 — IPC 契约模块化（无兼容层）

#### 目标
把 `ipc/contract/ipc-contract.ts`（62KB）从巨石拆成分域文件；旧结构不保留兼容入口。

#### 实施
- 新建并迁移：
  - `ipc/contract/error-codes.ts`
  - `ipc/contract/schemas/common.ts`
  - `ipc/contract/channels/ai.ts`
  - `ipc/contract/channels/context.ts`
  - `ipc/contract/channels/constraints.ts`
  - `ipc/contract/channels/memory.ts`
  - `ipc/contract/channels/project.ts`
  - `ipc/contract/channels/file.ts`
  - `ipc/contract/channels/version.ts`
  - `ipc/contract/channels/skill.ts`
  - `ipc/contract/channels/search.ts`
  - `ipc/contract/channels/export.ts`
- `ipc/contract/ipc-contract.ts` 仅做最终拼装（新结构，非旧接口兼容）。
- 更新脚本：
  - `scripts/contract-generate.ts`
  - `scripts/cross-module-contract-autofix.ts`
  - 去掉对"单文件文本结构"的依赖，改读聚合对象/生成结果。

#### 波及
- `ipc/runtime-validation.ts`
- `tests/unit/contract-generate.spec.ts`
- `tests/unit/contract-generate.validation.spec.ts`
- `tests/unit/cross-module-*.spec.ts`

---

### C2 — AI Runtime 破拆（无兼容导出）

#### 目标
把 `services/ai/aiService.ts`（65KB / 2441 行）拆为职责模块；旧内部函数不再保留原位置导出。

#### 实施
- 新结构：
  - `services/ai/provider/provider-config.ts` — ProviderConfig / ProviderResolution / ProviderMode 类型 + resolveProviderConfig
  - `services/ai/provider/provider-health.ts` — circuit breaker / half-open 恢复逻辑
  - `services/ai/transport/fetch-policy.ts` — rate limit / retry backoff / request dedup
  - `services/ai/transport/sse-reader.ts` — SSE 流读取 + chunk parse
  - `services/ai/runtime/run-registry.ts` — RunEntry Map + cancel / timeout / cleanup
  - `services/ai/runtime/session-budget.ts` — token 预算核算
  - `services/ai/executors/openai-executor.ts` — OpenAI/兼容 API 执行器
  - `services/ai/executors/anthropic-executor.ts` — Anthropic API 执行器
  - `services/ai/errors/upstream-error.ts` — 上游错误分类 + 可重试判断
- `aiService.ts` 仅保留编排层与对外 `createAiService`。
- 删除旧内部 helper 的同名保留与重导出。
- `aiProxySettingsService.ts` 保留原位但去除其本地 `ServiceResult` 定义（已由 C0 统一）。

#### 波及
- `ipc/ai.ts`
- `services/ai/__tests__/*.test.ts`

---

### C3 — Context Engine 破拆

#### 目标
把 `services/context/layerAssemblyService.ts`（35KB / 1249 行）拆分。当前类型定义、常量、budget 逻辑、assembly 管线、constraint trim、fetcher 编排全挤在单文件中。

#### 实施
- 新结构：
  - `services/context/types.ts` — 所有 Context 相关的 export type（ContextAssembleRequest, ContextLayerChunk, ContextBudgetProfile 等）
  - `services/context/constants.ts` — SLO_THRESHOLDS, CAPACITY_LIMITS, LAYER_ORDER, DEFAULT_BUDGET 等
  - `services/context/budget.ts` — budget profile 构建、更新、校验逻辑
  - `services/context/assembly.ts` — assemble / inspect 核心管线
  - `services/context/constraint-trim.ts` — rules constraint 降级 / trim 逻辑
- `layerAssemblyService.ts` 仅保留 `createContextLayerAssemblyService` 工厂，组装上述模块。
- fetchers 目录（`fetchers/rulesFetcher.ts` 等）不动，已独立。

#### 波及
- `ipc/context.ts`
- `ipc/ai.ts`
- `services/context/__tests__/*.test.ts`

---

### C4 — Composition Root + IPC Handler 统一重构

#### 目标
1. 建立 composition root：所有核心 service 在 `index.ts` 创建一次，注入给 handler。消除 create-per-call 反模式。
2. 拆掉所有 handler 巨石，按"register + handlers"模式重组。范围覆盖**全部** IPC handler，不仅限于 ai/context/constraints。

#### 执行拆分（新增）
- **C4A（先做）**：只做 composition root 与单实例注入改造，不做目录迁移。
- **C4B（后做）**：在 C4A 稳定后再做 IPC handler 目录化迁移（`*.ts` → `*/register.ts + handlers/*.ts`）。
- C4A/C4B 必须拆为两个可独立回滚的提交组，避免将“依赖注入变更”和“文件迁移变更”绑在同一变更集。

#### 实施 — C4A: Composition Root

在 `index.ts` 的 `registerIpcHandlers` 中一次性创建所有核心 service：
```
kgService           = createKnowledgeGraphService({ db, logger })
memoryService       = createMemoryService({ db, logger })
skillService        = createSkillService({ db, userDataDir, builtinSkillsDir, logger })
contextAssembly     = createContextLayerAssemblyService(undefined, { kgService, memoryService, ... })
aiService           = createAiService({ logger, env, getProxySettings })
```
所有 `register*IpcHandlers` 函数接收已创建的 service 实例，不再内部创建。

**修复 D2 双实例 bug**：`ipc/ai.ts` 和 `ipc/context.ts` 共享同一个 `contextAssemblyService` 实例，budget update 对所有调用路径生效。

#### 生命周期矩阵（新增，C4A 强制落地）

| 对象 | 生命周期 | 创建位置 | 释放/重置策略 |
|---|---|---|---|
| `kgService` / `memoryService` / `skillService` / `contextAssemblyService` / `aiService` | app-singleton（按 Electron main 进程） | `index.ts:registerIpcHandlers` | 进程退出时随主进程回收；测试中通过显式工厂重建隔离 |
| `watchService` | app-singleton | `index.ts:registerIpcHandlers` | `before-quit` 前停止 watch；测试需显式 stop |
| 单次请求临时对象（payload normalize / DTO） | request-scoped | handler 内 | 请求完成即释放，禁止跨请求缓存可变状态 |
| 缓存（若后续新增） | singleton + 明确 key 范围 | service 内 | 必须提供 `clear/reset` 供测试与故障恢复 |

#### 实施 — C4B: Handler 破拆

- **AI** (`ipc/ai.ts` → `ipc/ai/`)：
  - `ipc/ai/register.ts`
  - `ipc/ai/handlers/*.ts`
- **Context** (`ipc/context.ts` → `ipc/context/`)：
  - `ipc/context/register.ts`
  - `ipc/context/handlers/*.ts`
- **Constraints** (`ipc/constraints.ts` → `ipc/constraints/`)：
  - `ipc/constraints/register.ts`
  - `ipc/constraints/repo.ts`
  - `ipc/constraints/validators.ts`
- **Version** (`ipc/version.ts` → `ipc/version/`)：
  - `ipc/version/register.ts`
  - `ipc/version/handlers/*.ts`
  - 删除本地 `withTimeout`/`sleep`/`normalizeXxx`，改用 `lib/async-utils`（C0 已提供）。
- **Memory** (`ipc/memory.ts` → `ipc/memory/`)：
  - `ipc/memory/register.ts`
  - `ipc/memory/handlers/*.ts`
  - 消除 8x create-per-call。
- **Skills** (`ipc/skills.ts` → `ipc/skills/`)：
  - `ipc/skills/register.ts`
  - `ipc/skills/handlers/*.ts`
  - 消除 9x create-per-call。
- **KnowledgeGraph** (`ipc/knowledgeGraph.ts` → `ipc/kg/`)：
  - `ipc/kg/register.ts`
  - `ipc/kg/handlers/*.ts`
- 其余较小 handler（file/export/search/embedding/rag/stats/judge/aiProxy）视体量决定是否拆目录，但一律改为接收注入的 service 而非内部创建。
- 删除所有旧"单文件 handler 模式"。

#### 修复项（随本 change 一并处理）
- **D3 kgService 自引用**：`kgService.ts:2046` `rulesInjection` 方法改为直接调用闭包内 `queryRelevant`，删除自建实例。

#### 波及
- `index.ts`（composition root 重写）
- 全部 `ipc/*.ts`
- 全部 IPC 相关 unit/integration 测试

---

### C5 — AiPanel + AiStore 破拆（无兼容 hook/selector 别名）

#### 目标
把 `renderer/src/features/ai/AiPanel.tsx`（46KB）与 `renderer/src/stores/aiStore.ts`（16KB）拆分，直接切换新结构，不保留旧别名。

#### 实施
- Panel：
  - `features/ai/panel/AiPanel.tsx`
  - `features/ai/panel/hooks/use-ai-run-actions.ts`
  - `features/ai/panel/hooks/use-ai-selection-sync.ts`
  - `features/ai/panel/hooks/use-ai-judge-lifecycle.ts`
  - `features/ai/panel/components/*.tsx`
- Store：
  - `stores/ai/types.ts`
  - `stores/ai/state.ts`
  - `stores/ai/actions/*.ts`
  - `stores/ai/selectors.ts`
- 直接更新所有调用方 import 到新路径；不保留 `aiStore.ts` 过渡别名（可保留同名文件但内容即新实现，不做旧 API 包装）。
- 同步更新 OpenSpec delta（AI Service 模块 scope）与 cross-module baseline，避免“代码已迁移但规范路径仍旧值”。

#### 波及
- `features/ai/*.test.tsx`
- `features/ai/__tests__/*.test.tsx`
- `features/ai/AiPanel.stories.tsx`

---

## 执行顺序（锁定）

```
C0（共享基础设施）
 ↓
C1（契约基座）
 ↓
C2（AI runtime）── C3（Context Engine）  ← 并行开发
 ↓                  ↓
C4A（composition root + 单实例注入）
 ↓
C4B（全部 IPC handler 目录化）
 ↓
C5（panel + store）
 ↓
P3 功能 changes（audit-roadmap.md 的 C14-C21）
```

- C0 必须最先：后续所有 change 依赖统一的 `ServiceResult` / `ipcError` / `withTimeout`。
- C2 和 C3 可并行，但共享文件按所有权冻结，避免同文件冲突。
- C4A 依赖 C2 + C3（service 拆分完成后才能建立 composition root）。
- C4B 依赖 C4A（先稳定注入语义，再迁移 handler 目录）。
- C5 依赖 C4B（handler 注入模式稳定后再动 renderer 层）。

### 并行策略（新增，强制）

- C2/C3 并行期间，`index.ts`、`ipc/ai.ts`、`ipc/context.ts` 进入共享冻结；仅允许修复 blocker 的最小补丁。
- C2 以 `services/ai/**` 为主责，C3 以 `services/context/**` 为主责；跨域改动在 C4A 汇总接入。
- C4A 开始前必须完成一次 Dependency Sync Check，并在各自 `tasks.md` 与 RUN_LOG 写明“无漂移/已更新”。

---

## 治理执行单元（新增）

- C0~C5 每个 change 必须对应：
  - 一个独立 `openspec/changes/<change-id>/`（含 `proposal.md/specs/*/spec.md/tasks.md`）
  - 一个独立 Rulebook task（`active` 可验证）
- 每个 `tasks.md` 必须保持固定章节顺序：
  - `Specification → TDD Mapping → Red → Green → Refactor → Evidence`
- C4A/C4B 属于同一治理主题但必须分两个任务项，证据分别落盘，便于回滚与审计。
- 对存在上游依赖的 change，Red 前强制完成 `依赖同步检查（Dependency Sync Check）` 并记录结论。
- 每个 change 合并后，RUN_LOG 必须回填真实 PR 链接，且在收口前更新 `openspec/changes/EXECUTION_ORDER.md`。

---

## 关键接口变化（Important Interfaces / Types）

### 对外稳定（不改）
- IPC channel 名称与错误码集合（由契约生成的外部语义保持稳定）。
- renderer 与 main 的行为语义保持一致。

### 内部破坏（明确会变）
- `ServiceResult<T>` / `ipcError` 全局统一后，所有 service 文件 import 路径变更。
- `services/ai` 内部 helper 函数签名、路径、导出名。
- `services/context` 类型/常量/budget 逻辑拆分到独立文件。
- 全部 `ipc/*.ts` handler 从单文件模式迁移到目录模式，register 函数签名变更（接收注入 service 而非内部创建）。
- `features/ai` 内 hooks/组件分层路径，`stores/ai` 的 action/selectors 内部组织。
- 所有引用旧路径的 import 必须一次性迁移，不留兼容入口。

---

## 测试与验收场景（每个 change 必须覆盖）

1. **C0**：全量替换后行为不变（纯 import 替换，零逻辑变更）。
2. **C1**：契约等价性——拆分前后 `channel set` 与 `error code set` 一致；`contract:generate`/`contract:check`/`cross-module:check` 全绿。
3. **C2**：AI runtime——failover、retry/backoff、rate limit、session budget、stream cancel race、provider unavailable。
4. **C3**：Context Engine——assemble/inspect 输出等价性、budget update 生效、constraint trim 行为。
5. **C4**：
   - composition root：service 单实例验证（同一 db 上不存在多余实例）。
   - budget 同步：`context:budget:update` 后 AI skill run 使用新 budget。
   - register 完整性：所有 IPC channel 可达。
   - runtime validation 行为不变。
   - create-per-call 消除确认：grep `createMemoryService` / `createSkillService` / `createKnowledgeGraphService` 在**运行时代码路径**只出现在 `index.ts` 与 service 定义文件（`__tests__/**` 允许工厂调用）。
6. **C5**：AI panel——skill 触发、candidate 选择、apply/reject、judge 标签、usage stats。
7. **全局**：所有 required checks `ci`、`openspec-log-guard`、`merge-serial` 全绿。

### 命令矩阵（新增，最低要求）

| Change | 必跑命令（最低） |
|---|---|
| C0 | `pnpm typecheck` + `pnpm test:unit` |
| C1 | `pnpm typecheck` + `pnpm contract:check` + `pnpm cross-module:check` + `pnpm test:unit` + `pnpm test:ipc:acceptance` |
| C2 | `pnpm typecheck` + `pnpm test:unit` + AI 相关 unit/integration 子集 |
| C3 | `pnpm typecheck` + `pnpm test:unit` + Context 相关 unit/integration 子集 |
| C4A | `pnpm typecheck` + `pnpm test:unit` + `pnpm cross-module:check` |
| C4B | `pnpm typecheck` + `pnpm test:unit` + `pnpm contract:check` + `pnpm cross-module:check` + `pnpm test:ipc:acceptance` |
| C5 | `pnpm typecheck` + `pnpm test:unit` + AI panel/store 相关前端测试子集 |

---

## P3 准入门槛（Go / No-Go）

- C0~C5 全部 merged 到 `main`。
- 无兼容 shim 遗留（代码检索确认无 `legacy`, `compat`, `deprecated re-export` 过渡口）。
- `ServiceResult` / `ipcError` grep 确认只在 `lib/service-result.ts` 定义，其余文件仅 import。
- create-per-call 消除确认：核心 service factory 在运行时代码路径仅在 `index.ts` 调用（测试目录除外）。
- 命令矩阵要求全部满足，且受影响范围的 integration/ipc-acceptance 已执行并通过。
- 关键测试与 required checks 全绿。
- RUN_LOG 完整，PR 链接真实回填。
- `openspec/changes/EXECUTION_ORDER.md` 已更新到最新依赖状态。

---

## 假设与默认值

- 当前 `audit-roadmap.md` 以 Phase 1-6 为准；本方案只定义 P3 进入前的结构治理。
- 默认采用"行为不变重构"，但**内部不兼容**。
- 若发现"保持 IPC 对外语义稳定"与"内部破拆"冲突，优先保证 IPC 对外稳定，内部继续破拆。
