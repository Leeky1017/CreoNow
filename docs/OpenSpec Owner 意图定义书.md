# OpenSpec Owner 意图定义书（v0.1 草稿）

本文档记录项目 Owner 对 CreoNow 12 个模块的**行为意图和产品期望**，以及**跨模块的架构规范**，作为 Agent 起草正式 GIVEN/WHEN/THEN Spec 的输入。

---

# 一、Editor（编辑器）

**定位**：用户写作的核心界面，基于 TipTap 2 的所见即所得富文本编辑器。

### 1.1 文本编辑能力

- 编辑器为**富文本所见即所得**模式，不是 Markdown 源码编辑
- 底层存储格式为 TipTap JSON，用户无需感知
- 支持的排版能力：
  - 多级标题（至少 H1-H3）
  - 加粗、斜体、下划线、删除线
  - 有序列表、无序列表
  - 引用块
  - 分隔线
  - 具体格式清单以实际 TipTap 扩展配置为准，Agent 起草 spec 时应列出完整清单

### 1.2 AI 协作交互

- AI 修改结果应**直接在编辑器中呈现**，类似主流 IDE/CLI 的 inline diff 体验
- 用户能清晰看到：新增了多少字符、删除了多少字符
- 用户可以**逐条接受或拒绝** AI 的修改建议
- AI 的修改在被用户确认前，不应覆盖原文

### 1.3 Diff 对比模式

- 用户可以看到**红色标记的删减内容**和**绿色标记的新增改动**
- 支持最多 **4 个不同版本**的同时对比
- 已有可用的 Diff 组件，spec 应基于现有组件能力定义行为

### 1.4 禅模式（Zen Mode）

- 全屏（应用内全屏）的纯输入模式
- **没有 AI 辅助**，没有侧边栏，没有工具栏干扰
- 目的：让用户全力投入纯手写状态
- 进入和退出禅模式应有明确的操作入口

### 1.5 大纲视图（Outline）

- 对当前编辑的文章（或选定范围）生成**结构化的列表视图**
- 提供文档结构的全局概览
- 大纲视图作为编辑器的**附属功能**存在，不是独立模块

---

# 二、Skill System（技能系统）

**定位**：AI 能力的抽象层，将续写、改写、润色等能力封装为可调用的「技能」。

### 2.1 内置技能

- 系统预装一组**文字创作类**内置技能，包括但不限于：
  - 润色
  - 改写
  - 续写
  - 扩写
  - 缩写
  - 风格迁移
- Agent 起草 spec 时应列出完整的内置技能清单及每个技能的输入输出定义

### 2.2 触发方式

- 用户通过 **AI 面板中的技能按钮**触发技能
- 点击后弹出技能选择界面
- 默认状态下，技能**由用户主动调用**，作用于当前编辑器打开的文档

### 2.3 自定义技能

- 用户可以**新增、删除、修改**自定义技能
- 用户也可以通过自然语言描述需求，**让 AI 自动创建技能**
- 自定义技能与内置技能享有相同的调用方式

### 2.4 作用域管理

- 技能有三级作用域：builtin（内置）、global（全局）、project（项目级）
- 用户可以自行调整每个技能的作用范围
- 用户可以对技能进行**独立启停**控制

---

# 三、Knowledge Graph（知识图谱）

**定位**：管理创作中的实体（角色、地点、事件、物品、阵营）及其关系。

### 3.1 实体管理

- 用户可以直接打开知识图谱界面**手动添加节点**（实体）
- 支持的实体类型：角色、地点、事件、物品、阵营
- 每个实体有独立的详情页面，可填写属性和描述

### 3.2 关系管理

- 用户可以在实体之间**建立连线**（关系）
- 支持可视化的关系图展示
- 关系应有类型标签（如「敌对」「盟友」「父子」等）

### 3.3 自动识别

- 写作过程中新出现的角色/实体，系统应**自动识别并建议添加**到知识图谱
- 用户也可以随时**手动添加**
- 自动识别的结果需用户确认后才正式写入图谱

### 3.4 AI 续写中的知识图谱利用

- AI 续写时如果提到某个角色，**不应与知识图谱中该角色的设定矛盾**
- 如果用户新建了一个角色但未填写详细设定，AI 续写时**应避免胡编该角色的背景**
- AI 应优先使用知识图谱中的已有信息来保持叙事一致性
- 具体的技术实现（如何注入上下文、权重如何分配）由 Agent 在 spec 中定义，Owner 只审阅效果

### 3.5 扩展内容

- 知识图谱可扩展支持**时间线视图**：按时间轴展示事件发展
- 可扩展支持**角色卡**：为每个角色生成结构化的信息卡片

---

# 四、Workbench（工作台）

**定位**：用户打开应用后看到的主界面框架，承载所有功能模块的布局容器。

### 4.1 布局结构

- **左侧栏**：项目文件树、文档导航、知识图谱、记忆面板等功能入口
- **主编辑区**：编辑器主体
- **右侧面板**：仅包含 **AI 面板**和 **Info 面板**（当前编辑器中用户正在查看的文件信息）
- 各面板应支持显示/隐藏切换

### 4.2 右侧面板

- **AI 面板**：对话交互、技能按钮、AI 建议展示，可通过明确的入口呼出
- **Info 面板**：展示当前编辑器中打开文件的元信息
- 右侧面板**不放置**知识图谱、记忆面板等其他功能，这些功能统一在左侧栏管理

### 4.3 项目切换

- 左侧栏顶部设置**项目切换器**
- 点击后展示项目列表，支持搜索和按最近打开排序
- 切换项目时，整个工作台上下文（编辑器、知识图谱、记忆）全部跟随切换

---

# 五、Document Management（文档管理）

**定位**：创作项目中的文件和章节组织管理。

### 5.1 项目内容构成

一个创作项目至少包含以下类型的文档：

- **章节**：正文内容的基本单元
- **笔记**：创作过程中的随手记录
- **设定文档**：世界观、背景等参考资料
- **时间线**：事件发展的时序记录
- **角色卡**：角色的结构化信息
- 未来可能扩展更多文档类型

### 5.2 文档状态

- 文档区分**草稿**和**定稿**两种状态
- 状态切换应有明确的操作入口
- 状态应在文档列表中可见

### 5.3 章节组织

- 用户可以通过**拖拽排序**来调整章节顺序
- 文档之间应支持**互相引用**（如在正文中引用设定文档的内容）

### 5.4 大纲（Outline）的定位说明

- 大纲是 Editor 模块的附属功能，提供当前文档的结构化视图
- 大纲**不是**文档管理中的独立文档类型
- 文档管理中的「时间线」和「角色卡」是独立的文档类型，与大纲功能无关

---

# 六、Project Management（项目管理）

**定位**：创作项目的整体生命周期管理。

### 6.1 项目创建

- 支持两种创建方式：
  - **手动创建**：用户自行填写项目信息
  - **AI 辅助创建**：用户描述需求，AI 自动生成项目结构

### 6.2 项目元数据

- **基础信息**：项目名称、类型（小说/剧本/自媒体）、简介
- **创作目标**：目标字数、预计章节数
- **创作阶段**：大纲阶段 → 初稿 → 修改 → 定稿
- **风格设定**：叙述人称、语言风格、目标读者
- **关联配置**：默认使用的技能集、关联的知识图谱

### 6.3 多项目切换

- 通过 Workbench 左侧栏顶部的**项目切换器**实现
- 支持搜索和按最近打开排序
- 切换时整个工作台上下文跟随切换

---

# 七、Memory System（记忆系统）

**定位**：持续学习和记住用户的写作偏好与创作内容。

<aside>
📎

**详细设计参考**：本模块已有深度规划文档，Agent 起草 spec 时**必须阅读**以下资料：

- [1. 三层记忆架构](https://www.notion.so/1-9fe2d1e37c2a4073aaa51ee6c826fe2b?pvs=21)（工作记忆 / 情景记忆 / 语义记忆）
- [2. 记忆生命周期管理](https://www.notion.so/2-de441a0b81594882baf3d88b374ac507?pvs=21)（衰减模型 / 压缩策略 / 冲突检测）
- [3. 记忆可解释性与用户控制](https://www.notion.so/3-b9217ed4508d4dcfbeb04ed43f1d437e?pvs=21)（记忆面板 / 溯源机制 / 项目隔离）

以上文档位于 [🧠 记忆层与 Agentic 架构深化](https://www.notion.so/Agentic-a5186c6fcbf8491f8b4fab843bb770d8?pvs=21) 中，是本模块 spec 的核心输入。

</aside>

### 7.1 三层记忆架构

AI 应通过**三层记忆**分层记住尽可能多的内容：

- **工作记忆（Working Memory）**：当前编辑会话的实时上下文缓冲区，不持久化，会话结束时清除或压缩归档
- **情景记忆（Episodic Memory）**：具体的、可回溯的交互事件记录，是语义记忆蒸馏的原材料
- **语义记忆（Semantic Memory）**：从情景记忆中自动蒸馏出的抽象规律和偏好模型，可直接注入 prompt

记忆范围包括但不限于：

- 写作风格偏好（短句/长句、修辞手法、叙事节奏）
- 创作项目的核心设定
- 用户的修改习惯和反馈模式
- 用户对 AI 输出的显式和隐式反馈信号

### 7.2 用户可见性与控制

- 设计专门的**记忆面板**，用户可以查看 AI 当前记住了什么（语义记忆规则 + 置信度）
- 用户可执行的操作：**确认**（提升权重）、**修改**（手动编辑规则）、**删除**（永久移除错误偏好）、**手动添加**（直接告诉 AI 某个偏好）
- 支持**暂停学习**：冻结语义记忆蒸馏，适用于实验性写作场景
- 支持**记忆溯源**：用户可查看 AI 输出是基于哪些记忆做出的决策

### 7.3 记忆衰减与生命周期

- 采用基于**遗忘曲线**的时间衰减模型，召回次数越多衰减越慢
- 标记为「核心设定」或用户已确认的记忆**不受衰减影响**
- 被再次引用的记忆权重应恢复
- 衰减到阈值以下的情景记忆进入**压缩流程**（保留关键信号，释放原始数据），而非直接删除
- 记忆系统的任何子模块故障都**不应阻断核心写作功能**，有完整的降级策略

### 7.4 记忆隔离

- 记忆分为**全局级**和**项目级**两个作用域
- 项目级记忆优先于全局级，两者冲突时项目级覆盖全局级
- 用户可以手动将项目级规则提升为全局级
- 支持**项目级清除**（仅清除某个项目的记忆）和**全量清除**（恢复到全新用户状态）

---

# 八、Version Control（版本管理）

**定位**：管理写作内容的历史版本，支持回溯和对比。

### 8.1 版本历史入口

- 设置专门的**版本管理入口**（非隐藏功能，用户容易找到）
- 版本历史以**时间线列表**形式展示

### 8.2 AI 修改标记

- AI 的修改和用户的修改**默认不区分**显示
- 用户可以在设置中**选择开启区分显示**

### 8.3 版本操作

- **预览**：点击任意历史版本可以只读预览该版本的内容
- **对比**：用户可以选择两个版本进行 Diff 对比（复用编辑器的 Diff 组件）
- **回滚**：点击「恢复到此版本」后，系统**创建一个新版本**作为恢复点（而非删除中间版本），确保回滚操作本身可撤销

---

# 九、Search and Retrieval（搜索与检索）

**定位**：在创作项目中快速查找内容。

### 9.1 搜索范围

- 支持**全内容搜索**：所有与内容相关的东西都可搜
  - 全文搜索（章节正文）
  - 按角色/实体搜索
  - 按章节搜索
  - 笔记和设定文档搜索

### 9.2 搜索结果

- 搜索结果以**列表形式**展示
- 支持从搜索结果**直接跳转**到对应位置
- 搜索关键词在结果中应**高亮显示**

---

# 十、Context Engine（上下文引擎）

**定位**：组装 AI 推理时的上下文，确保 AI 获得相关且适量的信息。

<aside>
💡

本模块为技术密集型模块，以下为 Owner 定义的**效果要求**，技术实现细节由 Agent 在 spec 中补充。

</aside>

### 10.1 效果要求（按优先级排列）

1. **Immediate 层（最高优先级）**：AI 续写时**必须**知道当前章节的内容
2. **Rules 层**：AI **必须**遵守用户设定的创作规则（如「第一人称叙述」「主角不说脏话」）
3. **Settings 层**：AI **应该**记住并应用用户的风格偏好
4. **Retrieved 层**：AI 续写第 20 章时，**应该**能召回第 1 章中相关的关键设定

### 10.2 降级策略

- 当上下文总量超过模型 token 限制时，按优先级裁剪：**Immediate > Rules > Settings > Retrieved**
- 即使在极端裁剪情况下，Immediate 层的核心内容也不能被丢弃

---

# 十一、AI Service（AI 服务）

**定位**：与 LLM API 的通信层，管理模型调用和账户体系。

### 11.1 服务模式

- **默认模式（会员服务）**：用户使用 CreoNow 会员额度，无需配置 API Key
- **自带 Key 模式**：
  - 支持 **OpenAI 兼容协议**和 **Anthropic 兼容协议**
  - 用户只需填写 **Base URL + API Key** 即可完成配置
  - 配置界面应尽可能简洁

### 11.2 商业模式（参考）

- 主推**会员订阅制**
- 未来可扩展 **Pay-as-you-go**（按量付费）模式
- 整体参考 Cursor 的付费方案设计

---

# 十二、IPC（进程间通信）

**定位**：Electron 主进程与渲染进程之间的通信协议层。

<aside>
🔴

本模块为**纯技术基础设施**，Owner 不定义具体通道和消息。Agent 应根据现有代码和 IPC spec 占位符中的 Scope 信息自行起草完整 spec，Owner 仅做最终确认。

</aside>

### 12.1 Owner 要求

- 通信应可靠、类型安全
- 错误应被妥善处理，不应导致应用崩溃
- 具体的通道命名、消息类型、校验规则等由 Agent 定义，但必须遵循下方的架构规范

### 12.2 架构规范（Agent 必须遵循）

<aside>
📎

**调研来源**：基于 Electron 官方文档、[EIPC 框架](https://electron-ipc.com)（Schema-first 方案）和 [Orbit 应用的 Typed IPC 实践](https://heckmann.app/en/blog/electron-ipc-architecture/)（Domain-based 方案）综合得出。

</aside>

**原则一：Schema-first，类型化合同**

- 禁止使用裸字符串 channel name + `any` 类型的原始 IPC 方式
- 所有 IPC 通道必须通过 **TypeScript 类型映射（Type Map）** 定义，确保主进程和渲染进程共享同一份类型合同
- 修改 handler 函数签名时，TypeScript 应能在编译期标记所有受影响的调用位点
- 推荐参考：`alex8088/electron-toolkit` 的 Typed IPC Wrapper 或 EIPC 的 Schema DSL

**原则二：按业务域组织（Domain-based）**

- IPC 通道按业务域分组，与应用模块对齐，不要把所有通道平铺在一个文件里
- CreoNow 建议的域划分：
  - `editor` — 编辑器相关（文档读写、保存）
  - `ai` — AI 服务相关（技能调用、模型请求）
  - `project` — 项目管理相关
  - `knowledge` — 知识图谱相关
  - `memory` — 记忆系统相关
  - `system` — 系统级操作（窗口管理、文件对话框、更新等）
- 每个域导出三样东西：类型映射、注册函数、渲染层 API 对象

**原则三：三种通信模式，明确数据流向**

| **模式**          | **方向**                   | **Electron API**          | **典型场景**                         |
| ----------------- | -------------------------- | ------------------------- | ------------------------------------ |
| Request-Response  | Renderer → Main → Renderer | `invoke` / `handle`       | 读取文件、查询数据库、调用系统 API   |
| Fire-and-Forget   | Renderer → Main            | `send` / `on`             | 日志记录、统计事件、非关键通知       |
| Push Notification | Main → Renderer            | `webContents.send` / `on` | 文件变更通知、后台任务进度、系统事件 |

- 每个 IPC 通道必须明确属于以上哪种模式，禁止混用

**原则四：Preload Bridge 安全模式**

- 所有 IPC 必须通过 `contextBridge.exposeInMainWorld` 暴露，禁止在渲染进程直接使用 `ipcRenderer`
- Preload 脚本导出的 API 对象必须有完整的 TypeScript 类型声明
- 通过 `global.d.ts` 声明 `window.electronApi` 的类型，确保渲染层代码有完整的智能提示

**原则五：运行时校验**

- 所有从渲染进程进入主进程的数据必须进行**运行时参数校验**（不能仅依赖 TypeScript 编译期检查）
- 推荐使用 Zod 或类似的 schema validation 库
- 校验失败时应返回结构化错误，不应导致主进程崩溃

**原则六：统一错误处理**

- 定义统一的 IPC 错误格式（如 `{ success: boolean, data?: T, error?: { code: string, message: string } }`）
- Handler 中的未捕获异常应被全局拦截，转化为结构化错误返回给渲染进程
- 禁止主进程向渲染进程抛出原始 Error 对象（Electron 的 Structured Clone 不支持）

**原则七：可测试性**

- 每个 IPC handler 必须可独立测试（不依赖 Electron 环境）
- Handler 的业务逻辑应与 IPC 层解耦，通过依赖注入接收外部依赖
- IPC 契约测试（Contract Test）验证前后端对消息格式的理解一致

---

# 十三、前端 UI 架构规范（跨模块）

**定位**：Design Token → Tailwind CSS 4 → Storybook → 组件集成的全链路前端开发规范，适用于所有涉及 UI 的模块。

<aside>
🔴

本章为**跨模块强制约束**，Agent 在起草任何涉及 UI 组件的 spec 时都必须遵循。

</aside>

### 13.1 Design Token 是唯一的样式真相源

<aside>
📎

**调研来源**：基于 [Tailwind CSS 4 Design System 最佳实践](https://www.frontendtools.tech/blog/tailwind-css-best-practices-design-system-patterns) 和 [Storybook + Tailwind v4 语义化 Token 实践](https://www.designsystemscollective.com/my-journey-building-a-design-system-with-storybook-and-tailwind-css-v4-d463de06ae41) 综合得出。

</aside>

- **禁止在组件中直接使用 Tailwind 原始色值**（如 `bg-blue-500`），必须通过语义化 Token 引用（如 `bg-primary`、`text-content-secondary`）
- Token 定义集中在一个位置，Tailwind CSS 4 使用 **`@theme` 在 CSS 文件中定义**，不再使用旧版 `tailwind.config.js`
- Token 的命名采用三层结构：
  - **Primitive**（原始值）：`--color-blue-500: #3b82f6`
  - **Semantic**（语义别名）：`--color-primary: var(--color-blue-500)`
  - **Component**（组件级覆盖）：`--button-bg: var(--color-primary)`
- Agent 新增颜色、间距、字号时**必须走这条链路**，禁止跳过语义层直接引用原始值

### 13.2 组件必须先有 Story，再集成到页面

- 每个可复用的 UI 组件**必须附带 Storybook Story**，包含以下状态：
  - 默认态（Default）
  - 交互态（Hover / Focus / Active）
  - 边界态（空数据、超长文本、错误状态）
  - 禁用态（Disabled）
- Story 是组件的**可视化契约**，功能组件的提交如果没有对应 Story 则视为不完整
- Storybook 中应有专门的 **Token 文档页**，展示所有可用的颜色、间距、字号等 Token，确保设计与开发对齐

### 13.3 组件分层与命名

组件按三层组织，每层有明确的依赖边界：

| **层级** | **命名**   | **说明**                                                        | **允许的依赖**                |
| -------- | ---------- | --------------------------------------------------------------- | ----------------------------- |
| L1       | Primitives | 最小原子组件（Button、Input、Badge、Icon 等）                   | 仅依赖 Token，不含业务逻辑    |
| L2       | Composites | 由 Primitives 组合而成（SearchBar、ToolbarGroup、FormField 等） | 可依赖 L1 组件和 Token        |
| L3       | Features   | 业务级组件（AIPanel、KnowledgeGraphCard、MemoryPanel 等）       | 可依赖 L1/L2 组件、Store、IPC |

- 组件的文件夹结构必须与 Storybook 的目录结构**对齐**
- L1/L2 组件**禁止**直接调用 Zustand Store 或 IPC，只能通过 props 接收数据
- L3 组件可以连接 Store 和 IPC，但应将 UI 渲染逻辑与数据获取逻辑分离（Container/Presentational 模式）

### 13.4 Tailwind CSS 4 特有约束

- 使用 **CSS-first 配置**（`@theme` / `@layer`），不使用 `tailwind.config.js`
- **禁止 `@apply` 滥用**：如果一组 utility 反复出现，应提取为组件，而非用 `@apply` 创建新的 CSS class
- 响应式和暗色模式通过 **Token 层切换**，组件层不应直接写 `dark:` 前缀硬编码颜色值
- CreoNow 为桌面应用，响应式断点主要服务于**面板折叠/展开**场景，不是多设备适配

### 13.5 Storybook 与应用的一致性保障

- Storybook 的全局样式配置（`.storybook/preview.ts`）必须加载与应用**相同的 Tailwind CSS 入口文件**，确保 Token 一致
- 组件在 Storybook 中的渲染结果必须与集成到应用后一致，**不允许出现「Story 里正常但集成后样式崩溃」**的情况
- 新增或修改 Token 后，必须同时更新 Storybook 的 Token 文档页

---

# 附录：模块优先级与分工

| **优先级** | **模块**             | **Owner 参与度** | **起草方式**                        |
| ---------- | -------------------- | ---------------- | ----------------------------------- |
| 1          | Editor               | 高               | Owner 主导描述 → Agent 格式化       |
| 2          | Skill System         | 高               | Owner 主导描述 → Agent 格式化       |
| 3          | Knowledge Graph      | 高               | Owner 主导描述 → Agent 格式化       |
| 4          | Workbench            | 高               | Owner 主导描述 → Agent 格式化       |
| 5          | Document Mgmt        | 高               | Owner 主导描述 → Agent 格式化       |
| 6          | Project Mgmt         | 高               | Owner 主导描述 → Agent 格式化       |
| 7          | Memory System        | 中               | Owner 定义效果 → Agent 补充技术细节 |
| 8          | Version Control      | 中               | Owner 定义效果 → Agent 补充技术细节 |
| 9          | Search and Retrieval | 中               | Owner 定义效果 → Agent 补充技术细节 |
| 10         | Context Engine       | 低               | Agent 起草 → Owner 审阅效果         |
| 11         | AI Service           | 中               | Owner 定义模式 → Agent 补充技术细节 |
| 12         | IPC                  | 低               | Agent 自行起草 → Owner 最终确认     |

---

<aside>
📌

**下一步**：Agent 基于本文档，按优先级顺序为每个模块起草正式的 [`spec.md`](http://spec.md)（含 Requirements 和 GIVEN/WHEN/THEN Scenarios）。每个模块的 spec 起草完成后提交 Owner 审阅。

</aside>
