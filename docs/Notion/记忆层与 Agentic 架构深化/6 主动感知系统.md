# 6. 主动感知系统

<aside>
👁️‍🗨️

**核心思想**：从"用户发指令 → AI 响应"的被动模式，升级为"AI 主动发现问题并提醒用户"的协作模式。主动感知系统让 CN 像一个时刻关注作品的编辑——即使你没有问它，它也会在发现问题时轻轻拍你肩膀。

</aside>

---

## 1. 主动感知 vs 被动响应

| **维度** | **被动响应（当前）** | **主动感知（目标）** |
| --- | --- | --- |
| 触发方式 | 用户显式发起请求 | 系统在后台持续监测 |
| 发现问题的时机 | 用户意识到问题后才能让 AI 检查 | 问题产生时即被发现 |
| 用户体验 | "我得记住让 AI 帮我检查" | "AI 自己发现了我没注意到的问题" |
| 价值 | 工具 | 搭档 |

---

## 2. 三大主动感知能力

### 能力一：一致性守卫（Consistency Guardian）

**职责**：持续监测作品中的设定一致性，发现矛盾即提醒。

**监测对象**：

| **检查项** | **示例** | **检测方式** |
| --- | --- | --- |
| 角色属性矛盾 | 第五章说主角左撇子，第八章写主角用右手开枪 | 每次编辑保存时，提取涉及角色的属性描述，与知识图谱比对 |
| 时间线冲突 | "三天后"的事件发生在"两天后"的事件之前 | 解析时间标记，构建事件时间线，检测逻辑矛盾 |
| 地理矛盾 | 角色在同一天出现在两个相距甚远的城市 | 追踪角色位置变化，检测不合理的空间跳转 |
| 规则违反 | 世界观设定中"魔法在白天不可用"，但角色在白天使用了魔法 | 将 Rules 层规则作为约束条件，检测违规描写 |

**触发时机**：

- **实时轻量检查**：每次用户保存/自动保存时，对变更的段落做快速扫描
- **深度全文检查**：用户手动触发，或在长时间编辑后（如每写完一章）后台运行

**通知方式**：

```
┌─────────────────────────────────────────────┐
│  ⚠️ 一致性提醒                                │
├─────────────────────────────────────────────┤
│                                             │
│  在第八章第 3 段发现潜在矛盾：                  │
│                                             │
│  "他用右手稳稳地扣下了扳机"                     │
│                                             │
│  ⚡ 冲突：知识图谱记录林远为左撇子               │
│  📖 来源：第五章第 2 段                        │
│     "林远习惯性地用左手拿起了筷子"              │
│                                             │
│  [忽略] [修改当前段] [更新角色设定]              │
│                                             │
└─────────────────────────────────────────────┘
```

**用户响应选项**：

- **忽略**：标记为"已知不一致"，不再提醒
- **修改当前段**：跳转到问题位置，调用改写技能
- **更新角色设定**：修改知识图谱中的记录（可能是设定本身需要更新）

---

### 能力二：伏笔追踪器（Foreshadowing Tracker）

**职责**：自动追踪已埋下的伏笔，监控其回收状态。

#### 伏笔的生命周期

```
埋设 → 强化（可选）→ 回收 → 验证
  │                    │
  │                    └── 未回收的伏笔会被标记为"悬挂"
  │
  └── 用户手动标记 or AI 自动识别
```

#### 伏笔数据结构

```tsx
interface Foreshadowing {
  id: string;
  
  // 伏笔内容
  description: string;            // "红色信封中似乎藏着什么秘密"
  plantedAt: TextLocation;        // 埋设位置
  plantedChapter: string;
  
  // 关联实体
  relatedEntities: string[];      // 关联的角色、物品等知识图谱实体
  
  // 状态
  status: 'planted' | 'reinforced' | 'resolved' | 'abandoned';
  
  // 追踪记录
  reinforcements: TextLocation[];  // 强化位置（中间提及但未完全回收）
  resolution?: {
    location: TextLocation;
    chapter: string;
    method: string;               // 回收方式描述
  };
  
  // 元数据
  detectedBy: 'user' | 'ai';     // 谁标记的
  priority: 'high' | 'medium' | 'low';
  expectedResolutionChapter?: string; // 预期回收章节（可选）
}
```

#### 伏笔看板（UI）

```
┌─────────────────────────────────────────────┐
│  🎯 伏笔追踪看板                              │
├─────────────────────────────────────────────┤
│                                             │
│  🔴 待回收（3）                               │
│  ├ 红色信封（第3章埋设，已过 7 章未回收）  ⚠️    │
│  ├ 神秘电话（第5章埋设）                       │
│  └ 老照片上的陌生人（第6章埋设）               │
│                                             │
│  🟡 已强化（1）                               │
│  └ 消失的邻居（第2章埋设，第4、7章提及）        │
│                                             │
│  ✅ 已回收（5）                               │
│  ├ 断裂的钥匙（第1章→第4章）                   │
│  ├ 墙上的裂缝（第2章→第6章）                   │
│  └ ...更多                                   │
│                                             │
│  [+ 手动添加伏笔]                             │
│                                             │
└─────────────────────────────────────────────┘
```

#### 主动提醒规则

- **悬挂过久**：如果一个伏笔在埋设后超过 N 章（用户可配置，默认 5 章）仍未回收，发出提醒
- **即将遗忘**：如果当前章节适合回收某个伏笔（基于叙事节奏分析），主动建议
- **章节结束时**：每写完一章，展示"本章伏笔状态更新"

---

### 能力三：节奏分析器（Pacing Analyzer）

**职责**：分析作品的叙事节奏，提供可视化的节奏曲线和优化建议。

#### 节奏维度

```tsx
interface PacingAnalysis {
  chapter: string;
  
  // 场景类型分布
  sceneTypeDistribution: {
    dialogue: number;       // 对白占比
    action: number;         // 动作占比
    description: number;    // 描写占比
    reflection: number;     // 内心独白占比
    exposition: number;     // 说明/叙述占比
  };
  
  // 节奏指标
  metrics: {
    tensionCurve: number[];       // 紧张度曲线（按段落）
    avgSentenceLength: number;    // 平均句长
    dialogueDensity: number;      // 对白密度
    sceneChangeFrequency: number; // 场景切换频率
  };
  
  // 与前文的对比
  comparisonWithPrevious: {
    paceChange: 'faster' | 'slower' | 'similar';
    varietyScore: number;   // 场景类型多样性评分
  };
}
```

#### 节奏可视化

```
第六章   ████████░░░░░░░░ 紧张
第七章   ██████████████░░ 非常紧张
第八章   █████████████░░░ 紧张
第九章   ██████████████░░ 非常紧张    ← ⚠️ 连续高强度
第十章   ███████████████░ 非常紧张    ← ⚠️ 建议降速

💡 建议：最近 4 章持续高强度，读者可能出现疲劳。
   考虑在第十一章加入一个"呼吸场景"——角色的日常时刻或回忆片段。
```

#### 主动建议时机

- **章节完成时**：自动生成节奏分析报告
- **检测到异常时**：连续 3+ 章同类场景，或紧张度曲线持续走高/走低
- **用户进入新章节编辑时**：基于节奏分析，建议"这一章适合写什么类型的场景"

---

## 3. 主动感知的执行架构

### 后台监测循环

```tsx
class ProactivePerceptionEngine {
  private monitors: Monitor[] = [
    new ConsistencyGuardian(),
    new ForeshadowingTracker(),
    new PacingAnalyzer(),
  ];
  
  // 轻量检查：每次保存时触发
  async onSave(changedContent: ContentDelta): Promise<Alert[]> {
    const alerts: Alert[] = [];
    for (const monitor of this.monitors) {
      if (monitor.supportsIncrementalCheck) {
        const result = await monitor.incrementalCheck(changedContent);
        alerts.push(...result);
      }
    }
    return alerts;
  }
  
  // 深度检查：后台定时或手动触发
  async deepScan(scope: 'chapter' | 'full'): Promise<AnalysisReport> {
    const results = await Promise.all(
      this.monitors.map(m => m.deepScan(scope))
    );
    return this.mergeReports(results);
  }
}
```

### 通知优先级与打扰控制

<aside>
🔕

**设计原则**：主动感知应该像一个体贴的编辑——在你需要时提醒你，而不是不停地打扰你。

</aside>

| **优先级** | **通知方式** | **示例** |
| --- | --- | --- |
| 🔴 紧急 | 编辑器内嵌提示（不可忽略直到处理） | 角色名字写错了（可能是笔误而非设定矛盾） |
| 🟡 重要 | 侧边栏提示 + 角标 | 设定矛盾、伏笔悬挂过久 |
| 🟢 建议 | 仅在用户主动查看分析面板时展示 | 节奏建议、风格优化提示 |
| ⚪ 信息 | 静默记录，用户可在报告中查看 | 统计数据更新、学习进度 |

### 用户控制

- **全局开关**：用户可以完全关闭主动感知
- **分项开关**：独立控制每种监测能力的开关
- **免打扰模式**：在"专注写作"模式下暂停所有通知，退出后一次性展示累积提醒
- **灵敏度调节**：调整每种监测的触发阈值（宽松 / 标准 / 严格）

---

## 4. 主动感知与记忆系统的协同

主动感知的发现会**反哺记忆系统**：

- 一致性问题的处理结果 → 作为情景记忆存储（"用户在遇到左右手矛盾时选择了修改当前段"）
- 伏笔追踪数据 → 丰富知识图谱（自动识别的伏笔成为新的实体节点）
- 节奏分析结果 → 影响语义记忆（"用户倾向在紧张章节后安排过渡章节"）

这形成了一个**正反馈循环**：主动感知让系统更了解作品 → 更了解作品让记忆更精准 → 更精准的记忆让 AI 输出更好 → 更好的输出减少主动感知发现的问题。