# 2. 记忆生命周期管理

<aside>
♻️

**核心思想**：记忆不是只增不减的。没有生命周期管理的记忆系统最终会变成噪声库——召回的内容越来越不相关，AI 输出质量反而下降。

</aside>

---

## 记忆生命周期总览

```
创建 → 活跃使用 → 衰减 → 压缩/归档 → 淘汰/删除
  │                        │
  │    ◄── 被召回时重新激活 ──┘
  │
  └── 如果被用户标记为"永久保留" → 跳过衰减
```

---

## 1. 时间衰减模型

### 遗忘曲线（Forgetting Curve）

借鉴艾宾浩斯遗忘曲线，但针对创作场景做调整：

```tsx
function calculateDecay(episode: Episode, now: number): number {
  const ageInDays = (now - episode.timestamp) / (1000 * 60 * 60 * 24);
  const baseDecay = Math.exp(-0.1 * ageInDays); // 基础衰减
  
  // 召回次数越多，衰减越慢（类似间隔重复效应）
  const recallBoost = 1 + 0.2 * episode.meta.recallCount;
  
  // 重要性越高，衰减越慢
  const importanceBoost = 1 + 0.3 * episode.meta.importance;
  
  return Math.min(1.0, baseDecay * recallBoost * importanceBoost);
}
```

### 衰减分级

| **衰减等级** | **分数范围** | **状态** | **处理方式** |
| --- | --- | --- | --- |
| 🟢 活跃 | 0.7 - 1.0 | 正常参与召回 | 无需处理 |
| 🟡 衰减中 | 0.3 - 0.7 | 降低召回优先级 | 如被召回则重新激活 |
| 🟠 待压缩 | 0.1 - 0.3 | 不再参与召回 | 等待批量压缩 |
| 🔴 待淘汰 | < 0.1 | 候选删除 | 下次清理时删除 |

---

## 2. 记忆压缩策略

当情景记忆进入"待压缩"状态时，不是直接删除，而是**压缩为摘要**：

### 压缩流程

```
原始情景记忆（完整的交互记录，可能 2000+ tokens）
       │
       ▼
   AI 摘要提取（保留关键信号）
       │
       ▼
   压缩后的情景记忆（~200 tokens）
       │
       ▼
   标记 compressed = true，释放原始数据
```

### 压缩保留什么？

- ✅ 场景类型 + 使用的技能
- ✅ 用户反馈（正/负/中性）
- ✅ 关键偏好信号（"用户把长句改成了短句"）
- ✅ 最终采用的文本风格特征
- ❌ 完整的 AI 候选方案
- ❌ 完整的输入上下文
- ❌ 逐字的编辑历史

### 压缩示例

**压缩前**（完整情景，~1800 tokens）：

> 2026-03-15 14:32，用户在《暗流》第七章使用续写技能。输入上下文：林远站在废弃仓库门口，手里的枪还在微微发抖……（此处省略 800 字）。AI 生成 3 个候选方案：方案 A（200 字）、方案 B（180 字）、方案 C（220 字）。用户选择方案 B 并做了修改：将"他深吸一口气，缓缓推开了门"改为"他踹开门"。editDistance = 15%。
> 

**压缩后**（~150 tokens）：

> 续写 | 动作场景 | 《暗流》第七章 | 弱正反馈 | 用户将舒缓动作描写改为干脆利落的短句 | 偏好信号：动作场景倾向快节奏、省略心理描写
> 

---

## 3. 记忆冲突检测与解决

### 什么是记忆冲突？

用户的创作偏好可能随时间变化。例如：

- 早期偏好华丽辞藻，后来转向简洁风格
- 在 A 项目中偏好第一人称，在 B 项目中偏好第三人称
- 心情好时接受 AI 的大胆改写，心情差时只接受保守修改

### 冲突检测机制

```tsx
interface ConflictDetection {
  // 当新的语义记忆规则与现有规则矛盾时触发
  detectConflict(
    newRule: SemanticMemoryEntry, 
    existingRules: SemanticMemoryEntry[]
  ): Conflict[];
}

interface Conflict {
  newRule: SemanticMemoryEntry;
  existingRule: SemanticMemoryEntry;
  conflictType: 
    | 'direct_contradiction'  // 直接矛盾："偏好长句" vs "偏好短句"
    | 'scope_overlap'         // 作用域重叠：全局规则与项目规则冲突
    | 'temporal_shift';       // 时间迁移：同一偏好的不同阶段
  resolution: ConflictResolution;
}
```

### 冲突解决策略

| **冲突类型** | **自动解决策略** | **需要用户确认？** |
| --- | --- | --- |
| 时间迁移（新旧偏好不同） | 以近 30 天的情景为准，自动更新规则 | 否，但在记忆面板标注"最近更新" |
| 作用域重叠（全局 vs 项目） | 项目级规则优先，全局规则降权 | 否 |
| 直接矛盾（同一时期两条互斥规则） | 降低两条规则的置信度 | 是，弹出提示让用户选择 |

---

## 4. 存储预算与清理调度

### 存储预算

| **记忆类型** | **预算** | **超出处理** |
| --- | --- | --- |
| 工作记忆 | 8K tokens（内存） | 按重要性淘汰 |
| 情景记忆（活跃） | 最近 1000 条 | 衰减 → 压缩 |
| 情景记忆（压缩） | 最近 5000 条 | 衰减 → 淘汰 |
| 语义记忆 | 最多 200 条规则 | 按置信度淘汰低分规则 |

### 清理调度

- **实时**：工作记忆的淘汰（每次写入时检查）
- **每日**：情景记忆衰减分数重算（应用启动时或后台定时）
- **每周**：批量压缩 + 语义记忆蒸馏
- **每月**：淘汰已压缩的过期情景记忆

---

## 5. 确定性降级策略

<aside>
⚠️

**设计原则**：记忆系统的任何子模块故障都不应阻断核心写作功能。

</aside>

| **故障场景** | **降级策略** | **用户感知** |
| --- | --- | --- |
| 向量索引不可用（无法语义召回情景） | 回退到时间 + 场景类型的精确匹配 | 召回精度下降，但不中断 |
| 语义记忆为空（新用户 / 新项目） | 使用内置默认规则 + 用户在 Settings 层的显式设定 | AI 输出偏通用，随使用逐渐个性化 |
| 情景记忆数据库损坏 | 语义记忆仍可用（已蒸馏的规则独立于原始数据） | 失去具体案例参考，但偏好规则仍在 |
| 全部记忆不可用 | 仅依赖上下文引擎的 Rules 和 Immediate 层 | 等同于无记忆模式，基础功能完整 |