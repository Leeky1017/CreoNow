# 3. 记忆可解释性与用户控制

<aside>
👁️

**核心思想**：AI 对创作者的"理解"必须是透明的、可干预的。创作者不是被 AI 服务的被动用户，而是与 AI 协作的主体。如果创作者无法看到、理解和修正 AI 的记忆，信任就无法建立。

</aside>

---

## 1. 记忆面板（Memory Panel）

### 设计目标

为用户提供一个**统一的界面**，展示 AI 对"我"的理解，并允许直接修正。

### 面板结构

```
┌─────────────────────────────────────────┐
│  🧠 AI 对你的理解          [全局 | 本项目] │
├─────────────────────────────────────────┤
│                                         │
│  📝 写作风格                              │
│  ┌─────────────────────────────────┐    │
│  │ • 动作场景偏好短句 (置信度 87%)   │    │
│  │   [✓ 确认] [✏️ 修改] [🗑 删除]   │    │
│  │                                 │    │
│  │ • 对白风格口语化 (置信度 92%)     │    │
│  │   ✅ 已确认                      │    │
│  │                                 │    │
│  │ • 少用嗅觉描写 (置信度 71%)      │    │
│  │   [✓ 确认] [✏️ 修改] [🗑 删除]   │    │
│  └─────────────────────────────────┘    │
│                                         │
│  🎭 叙事偏好                              │
│  ┌─────────────────────────────────┐    │
│  │ • 严格第一人称 (置信度 95%)       │    │
│  │   ✅ 已确认                      │    │
│  └─────────────────────────────────┘    │
│                                         │
│  📊 学习进度                              │
│  已积累 347 个交互记录                     │
│  最近更新: 2 小时前                        │
│  [查看学习历史] [手动添加规则]              │
│                                         │
└─────────────────────────────────────────┘
```

### 用户可执行的操作

| **操作** | **效果** | **适用场景** |
| --- | --- | --- |
| **确认** | 将规则标记为 userConfirmed，提升权重，不再被自动更新覆盖 | AI 学到了正确的偏好 |
| **修改** | 用户手动编辑规则文本，标记为 userModified | AI 方向对但表述不准确 |
| **删除** | 永久移除该规则，并将支撑情景标记为"负向"以避免重新蒸馏 | AI 学到了错误的偏好 |
| **手动添加** | 用户直接写入一条偏好规则，置信度 = 1.0，userConfirmed = true | 用户想直接告诉 AI 某个偏好，而不是等它慢慢学 |
| **暂停学习** | 冻结语义记忆蒸馏，停止从新情景中更新规则 | 用户在做实验性写作，不想污染已有偏好 |

---

## 2. 记忆溯源（Memory Provenance）

### 为什么需要溯源？

当 AI 输出了某个风格的文本时，用户可能会问：*"你为什么这样写？"* 系统需要能追溯到**是哪条记忆驱动了这个决策**。

### 溯源机制

每次 AI 生成内容时，在内部记录**记忆引用链**：

```tsx
interface GenerationTrace {
  generationId: string;
  
  // 本次生成参考了哪些记忆
  memoryReferences: {
    workingMemory: string[];        // 引用的工作记忆项 ID
    episodicMemory: string[];       // 引用的情景记忆 ID
    semanticMemory: string[];       // 引用的语义记忆规则 ID
  };
  
  // 每条记忆对最终输出的影响权重
  influenceWeights: Map<string, number>;
}
```

### 用户可见的溯源 UI

当用户对 AI 输出好奇或不满时，可以点击"为什么这样写？"查看：

```
┌─────────────────────────────────────────────┐
│  🔍 AI 决策溯源                               │
├─────────────────────────────────────────────┤
│                                             │
│  本次续写参考了以下记忆：                       │
│                                             │
│  📌 语义记忆                                  │
│  • "动作场景偏好短句"（影响权重: 35%）          │
│  • "对白风格口语化"（影响权重: 20%）            │
│                                             │
│  📖 情景记忆                                  │
│  • 3月15日 第七章打斗场景续写                   │
│    → 你选择了方案B并改为更简练的句子             │
│    （影响权重: 25%）                           │
│                                             │
│  📝 工作记忆                                  │
│  • 当前章节的前文语境（影响权重: 20%）           │
│                                             │
│  [反馈: 这次判断正确 ✓] [反馈: 判断有误 ✗]      │
│                                             │
└─────────────────────────────────────────────┘
```

---

## 3. 记忆隔离与项目边界

### 问题

用户可能同时在写多个项目，每个项目的风格完全不同。记忆系统需要支持**项目级隔离**。

### 记忆作用域模型

```
┌─────────────────────────────────────────┐
│              全局记忆                     │
│  （跨项目通用的偏好，如：偏好短句）         │
├──────────────────┬──────────────────────┤
│   项目 A 记忆     │    项目 B 记忆        │
│  （仅适用于本项目） │  （仅适用于本项目）    │
│  如：第一人称      │  如：第三人称         │
│  如：现代都市背景   │  如：奇幻世界观       │
└──────────────────┴──────────────────────┘
```

### 作用域优先级

1. **项目级语义记忆** > **全局级语义记忆**
2. 如果项目级无匹配规则，回退到全局级
3. 如果两者冲突，项目级覆盖全局级
4. 用户可以手动将项目级规则"提升"为全局级

---

## 4. 隐私与数据安全

<aside>
🔒

CN 是本地应用，所有记忆数据 **100% 存储在用户本地**（SQLite）。但仍需注意以下安全设计。

</aside>

- **记忆导出**：用户可以导出全部记忆数据（JSON 格式），用于迁移或备份
- **记忆清除**：一键清除所有记忆，恢复到"全新用户"状态
- **项目级清除**：仅清除某个项目的记忆，不影响其他项目
- **AI 调用时的记忆脱敏**：当记忆内容需要发送到远程 AI API 时，敏感内容（如角色名、地名）可以用占位符替换，推理完成后再替换回来